{"remainingRequest":"/Volumes/PersonHD/Company Project/github/hankLog/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!/Volumes/PersonHD/Company Project/github/hankLog/node_modules/cache-loader/dist/cjs.js??ref--1-0!/Volumes/PersonHD/Company Project/github/hankLog/node_modules/vue-loader/lib/index.js??ref--1-1!/Volumes/PersonHD/Company Project/github/hankLog/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Volumes/PersonHD/Company Project/github/hankLog/docs/basics/EventLoop.md?vue&type=template&id=08164533&","dependencies":[{"path":"/Volumes/PersonHD/Company Project/github/hankLog/docs/basics/EventLoop.md","mtime":1536111099000},{"path":"/Volumes/PersonHD/Company Project/github/hankLog/node_modules/cache-loader/dist/cjs.js","mtime":0},{"path":"/Volumes/PersonHD/Company Project/github/hankLog/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":499162500000},{"path":"/Volumes/PersonHD/Company Project/github/hankLog/node_modules/cache-loader/dist/cjs.js","mtime":0},{"path":"/Volumes/PersonHD/Company Project/github/hankLog/node_modules/vue-loader/lib/index.js","mtime":499162500000},{"path":"/Volumes/PersonHD/Company Project/github/hankLog/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":1533872387000}],"contextDependencies":[],"result":["var render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _vm._m(0)\n}\nvar staticRenderFns = [\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"div\", { staticClass: \"content\" }, [\n      _c(\"h1\", { attrs: { id: \"eventloop\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#eventloop\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" EventLoop\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"h2\", { attrs: { id: \"event-loop如何理解\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#event-loop如何理解\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" Event loop如何理解\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\n          \"面试的经常会被问到，什么事Event loop，面试官想知道什么呢，我们又该如何回答呢？\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\"Event Loop顾名思义就是事件循环，为什么要用事件循环？因为V8是\"),\n        _c(\"code\", [_vm._v(\"单线程\")]),\n        _vm._v(\n          \"的，即同一时间只能干一件事情，但是文件的读取和网络IO处理会很慢，并且时间不确定的，如果同步等待它们的响应，估计用户早飞了，于是我们就把这个事件加入到一个\"\n        ),\n        _c(\"code\", [_vm._v(\"事件队里（task）\")]),\n        _vm._v(\",等到事件完成时，event loop再执行一个事件队列。\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"h2\", { attrs: { id: \"event-loop执行顺序\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#event-loop执行顺序\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" Event loop执行顺序\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\n          \"注意：每种异步事件加入的事件队列是不一样的，唯一的2个限制是同一个任务源中的事件必须属于同一个队列，并且必须在每个队列中按照插入顺序处理任务。也就是说由系统提供的执行task的方法，如 setTimeout/setInterval/setImmediate 会在一个task，网络IO会在一个task,用户事件会在一个task,event loop将会按照以下顺序执行：\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _vm._v(\"1.update_time\"),\n          _c(\"br\"),\n          _vm._v(\n            \"\\n在事件循环的开头，这一步的作用实际上是为了获取以下系统时间，以保证之后的timer触发的准确性。（好像也不太准确...）\"\n          )\n        ]),\n        _vm._v(\" \"),\n        _c(\"li\", [\n          _vm._v(\"2.timer\"),\n          _c(\"br\"),\n          _vm._v(\n            \"\\n事循环跑到这个阶段的时候，要检查是否有到期的timer,其实也就是setTimeout和setInterval这种类型的timer,到期了，就会执行他们的回调。\"\n          )\n        ]),\n        _vm._v(\" \"),\n        _c(\"li\", [\n          _vm._v(\"3.I/O callbacks\"),\n          _c(\"br\"),\n          _vm._v(\n            \"\\n处理异步事件的回调，比如网络I/O,比如文件读取I/O。当这些I/O动作都结束的时候，这个阶段会触发他们的回调。\"\n          )\n        ]),\n        _vm._v(\" \"),\n        _c(\"li\", [\n          _vm._v(\"4.idle,prepare\"),\n          _c(\"br\"),\n          _vm._v(\"\\n这个阶段内部做一些动作，与理解事件循环没啥关系\")\n        ]),\n        _vm._v(\" \"),\n        _c(\"li\", [\n          _vm._v(\"5.I/O poll阶段\"),\n          _c(\"br\"),\n          _vm._v(\n            \"\\n这个阶段相当有意思，也是事件循环设计的一个有趣的点，这个阶段是\"\n          ),\n          _c(\"code\", [_vm._v(\"选择运行\")]),\n          _vm._v(\"（不一定会运行，后续详解）的。\")\n        ]),\n        _vm._v(\" \"),\n        _c(\"li\", [\n          _vm._v(\"6.check\"),\n          _c(\"br\"),\n          _vm._v(\"\\n执行setImmediate操作\")\n        ]),\n        _vm._v(\" \"),\n        _c(\"li\", [\n          _c(\"ol\", { attrs: { start: \"7\" } }, [\n            _c(\"li\", [\n              _vm._v(\"Close callbacks\"),\n              _c(\"br\"),\n              _vm._v(\"\\n关闭I/O 的动作，比如文件描述符的关闭，链接断开，等等\"),\n              _c(\"br\"),\n              _vm._v(\" \"),\n              _c(\"img\", {\n                attrs: {\n                  src: \"/images/eventloop-1.jpg\",\n                  alt: \"Event loop执行顺序\"\n                }\n              })\n            ])\n          ])\n        ])\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\"除了task还有一个\"),\n        _c(\"code\", [_vm._v(\"microtask\")]),\n        _vm._v(\"（微任务），这一个概念是ES6提出\"),\n        _c(\"code\", [_vm._v(\"Promise\")]),\n        _vm._v(\"以后出现的。这个\"),\n        _c(\"code\", [_vm._v(\"microtask queue\")]),\n        _vm._v(\n          \"只有一个。并且会在且一定会在每一个task后执行，且执行是按顺序的。加入到\"\n        ),\n        _c(\"code\", [_vm._v(\"microtask\")]),\n        _vm._v(\"的事件类型有\"),\n        _c(\"code\", [_vm._v(\"Promise.resolve().then()\")]),\n        _vm._v(\", \"),\n        _c(\"code\", [_vm._v(\"process.nextTick()\")]),\n        _vm._v(\" 值得注意的是，event loop一定会在执行完\"),\n        _c(\"code\", [_vm._v(\"microtask\")]),\n        _vm._v(\"以后才会寻找新的可执行的task队列。而\"),\n        _c(\"code\", [_vm._v(\"microtask\")]),\n        _vm._v(\"事件内部又可以产生新的\"),\n        _c(\"code\", [_vm._v(\"microtask\")]),\n        _vm._v(\"事件比如\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"div\", { staticClass: \"language-javascript line-numbers-mode\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-javascript\" } }, [\n          _c(\"code\", [\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\"(\")\n            ]),\n            _c(\"span\", { attrs: { class: \"token keyword\" } }, [\n              _vm._v(\"function\")\n            ]),\n            _vm._v(\" \"),\n            _c(\"span\", { attrs: { class: \"token function\" } }, [\n              _vm._v(\"microtask\")\n            ]),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\"(\")\n            ]),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\")\")\n            ]),\n            _vm._v(\" \"),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\"{\")\n            ]),\n            _vm._v(\"\\n    process\"),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\".\")\n            ]),\n            _c(\"span\", { attrs: { class: \"token function\" } }, [\n              _vm._v(\"nextTick\")\n            ]),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\"(\")\n            ]),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\"(\")\n            ]),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\")\")\n            ]),\n            _vm._v(\" \"),\n            _c(\"span\", { attrs: { class: \"token operator\" } }, [_vm._v(\"=>\")]),\n            _vm._v(\" \"),\n            _c(\"span\", { attrs: { class: \"token function\" } }, [\n              _vm._v(\"microtask\")\n            ]),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\"(\")\n            ]),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\")\")\n            ]),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\")\")\n            ]),\n            _vm._v(\"\\n\"),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\"}\")\n            ]),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\")\")\n            ]),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\"(\")\n            ]),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\")\")\n            ]),\n            _vm._v(\"\\n\")\n          ])\n        ]),\n        _vm._v(\" \"),\n        _c(\"div\", { staticClass: \"line-numbers-wrapper\" }, [\n          _c(\"span\", { staticClass: \"line-number\" }, [_vm._v(\"1\")]),\n          _c(\"br\"),\n          _c(\"span\", { staticClass: \"line-number\" }, [_vm._v(\"2\")]),\n          _c(\"br\"),\n          _c(\"span\", { staticClass: \"line-number\" }, [_vm._v(\"3\")]),\n          _c(\"br\")\n        ])\n      ]),\n      _c(\"p\", [\n        _vm._v(\"这样就会不断的在\"),\n        _c(\"code\", [_vm._v(\"microtask queue\")]),\n        _vm._v(\"添加事件，导致整个eventloop堵塞\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\n          \"最后就是一个渲染的事件队列，这个队列只出现在浏览器上，并且执行环境会根据情况决定执行与否(可能执行很多task queue也不执行渲染队列)。它如果执行则一定会在microtask后执行，通过\"\n        ),\n        _c(\"code\", [_vm._v(\"requestAnimationFrame(handle)\")]),\n        _vm._v(\" 方法,能够保证中间的代码一定能在下一次执行渲染函数前执行\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\"补充常见的产生\"),\n        _c(\"code\", [_vm._v(\"microtask\")]),\n        _vm._v(\"和\"),\n        _c(\"code\", [_vm._v(\"task\")]),\n        _vm._v(\"事件的方法\"),\n        _c(\"br\"),\n        _vm._v(\" \"),\n        _c(\"strong\", [_vm._v(\"microtasks:\")])\n      ]),\n      _vm._v(\" \"),\n      _c(\"ul\", [\n        _c(\"li\", [_vm._v(\"process.nextTick\")]),\n        _vm._v(\" \"),\n        _c(\"li\", [_vm._v(\"promise\")]),\n        _vm._v(\" \"),\n        _c(\"li\", [_vm._v(\"Object.observe\")]),\n        _vm._v(\" \"),\n        _c(\"li\", [\n          _vm._v(\"MutationObserver\"),\n          _c(\"br\"),\n          _vm._v(\" \"),\n          _c(\"strong\", [_vm._v(\"tasks:\")])\n        ]),\n        _vm._v(\" \"),\n        _c(\"li\", [_vm._v(\"setTimeout\")]),\n        _vm._v(\" \"),\n        _c(\"li\", [_vm._v(\"setInterval\")]),\n        _vm._v(\" \"),\n        _c(\"li\", [_vm._v(\"setImmediate\")]),\n        _vm._v(\" \"),\n        _c(\"li\", [_vm._v(\"I/O\")]),\n        _vm._v(\" \"),\n        _c(\"li\", [_vm._v(\"UI渲染\")]),\n        _vm._v(\" \"),\n        _c(\"li\", [_vm._v(\"Tips\")])\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\n          \"我们通过node运行一个js文件，如果没有可执行事件的事件队列，进程就会退出，那么怎么不让它退出呢？\"\n        ),\n        _c(\"br\"),\n        _vm._v(\n          \"\\nsetInterval方法，这货会一直循环建立新的事件，这样能够保证node进程不退出\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\n          \"监听 beforeExit 事件，通过process.on('beforeExit', handle) 这个事件在node进程退出前会触发，但是如果这里面的handle包含了一个可以生成异步事件的操作，则node进程也不会退出。手动触发process.exit(EXIT_CODE)不会触发该事件\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\n          \"setInterval会导致node进程不能正常退出，但是如果希望即使有setInterval也能正常退出怎么办(有一些循环并不希望挂起node进程)？\"\n        ),\n        _c(\"br\"),\n        _vm._v(\n          \"\\nconst timer = process.setInterval(handle, deley) 调用setInterval方法会返回一个timer，调用 timer.unref() 则event-loop判断除它以外，没有可进行的事件队列后也会推出\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\"process.on('exit', handle)中，handle里的异步事件不能执行\"),\n        _c(\"br\"),\n        _vm._v(\n          \"\\nexit事件在手动执行process.exit(EXIT_CODE)后，或者event loop中没有可执行的事件队列 时触发。触发 exit 事件后，执行环境就不会再生成新的 事件队列了，因此这里面的异步事件都会被强制队列\"\n        )\n      ])\n    ])\n  }\n]\nrender._withStripped = true\n\nexport { render, staticRenderFns }"]}